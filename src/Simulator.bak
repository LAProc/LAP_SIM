//============================================================================
// Name        : Simulator.cpp
// Author      : Ardavan Pedram
// Version     :
// Copyright   : All rights reserved for FLAME @ UTEXAS
// Description : Simulator in C++, Ansi-style
//============================================================================



#include <iostream>
#include <iomanip>
#include <fstream>
#include "Parameters.h"
#include "LAPU.h"

int Kernel_Size;
int Panel_Size;
int NumofKernel;
int Mem_Size_A;
int Mem_Size_B1;
int Mem_Size_B2;


using namespace std;

int Global_Chol ();
int Global_Gemm( double **& A, double **& B, double **& C);
 int initialize_Chol_Matrix(int size, double **& matrix_A);
void print_matrix(int rows, int columns, double ** matrix_A);

void dump_matrix_file(int rows, int columns, double ** matrix_A, ofstream& A_file, char type, int precision);

void make_test_matrix(int rows, int columns, double **& test_matrix, int preset, Test_Matrix type);

void Read_Matrix(char* type, double **& matrix, Matrix_Type mat );

LAPU * Accelerator;

int main(int argc, char* argv[] ) {
	cout << "!!!Linear Algebra Processor Simulator Version 0.1 !!!" << endl; // prints !!!Hello World!!!
	cout << "!!!Current Version: GEMM and Linear Algebra Core !!!" << endl; // prints !!!Hello World!!!

//	std::cout.unsetf ( std::ios::floatfield );                // floatfield not set
//	std::cout.precision(5);
	setprecision(4);

	int x=0;
	double ** example1;
	double ** example2;
	double ** example3;

	double ** matmul_example_A;
	double ** matmul_example_B;
	double ** matmul_example_C;


  ifstream in_A("Matr_A.txt");  

  if (!in_A) {
      cout << "Cannot open matrix A "  <<endl;
      exit(0);
  }

  ifstream in_B("Matr_B.txt");  

  if (!in_B) {
      cout << "Cannot open matrix B " <<endl;
      exit(0);
  }

  int Rows_A, Rows_B, Cols_B ;

  //read number of kernel
  in_A >> Rows_A;

  //read Kernel size
  in_A >> Kernel_Size;

  in_B >> Rows_B;
  in_B >> Panel_Size;

  NumofKernel = Rows_A/Kernel_Size;
  
  //Set up the memory size
  Mem_Size_A = (Buffer_local_mem_A * Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size);
  Mem_Size_B1 = Kernel_Size;
  Mem_Size_B2 = Kernel_Size;

  printf("Mem_Size A is %d\n", Mem_Size_A);
  printf("Mem_Size B1 is %d\n", Mem_Size_B1);
  printf("Mem_Size B2 is %d\n", Mem_Size_B2);

  Accelerator= new LAPU();
  
  Read_Matrix("Matr_A.txt", example1, Mat_A);
  Read_Matrix("Matr_B.txt", example2, Mat_B);
  Read_Matrix("Matr_C.txt", example3, Mat_C);

  int numofarg = argc;


  FILE *A_file;
  FILE *B_file;
  FILE *C_file;


  /*prgName   = argv[0];
  inFile = argv[1];
  outFile = argv[2];*/

    if (numofarg!=4)
        {
          printf("File names to store the generated example matrices: <Matrix A> <Matrix B> <Matrix C> \n");
        }

  ofstream A_file0;
	ofstream B_file0;
	ofstream C_file0;

	A_file0.open (argv[1]);
	B_file0.open (argv[2]);
	C_file0.open (argv[3]);


    if (! (A_file0.is_open())){
        cout<<"Error, failed to open file"<< argv[1]<<endl;
        return 0;
    }


    if (! (B_file0.is_open())){
        cout<<"Error, failed to open file"<< argv[2]<<endl;
        return 0;
    }


    if (! (C_file0.is_open())){
        cout<<"Error, failed to open file"<< argv[3]<<endl;
        return 0;
    }


  

  //The format of input files is Matr_? A, B or C


	//make_test_matrix(Kernel_Size * NumofKernel ,Kernel_Size,matmul_example_A,1,'s');
	//make_test_matrix(Kernel_Size * NumofKernel ,Kernel_Size,matmul_example_A,1,'f');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'^');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'s');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'l');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'k');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,2,'D');


  //This is basically creating matrices A B C

  make_test_matrix(Kernel_Size * NumofKernel ,Kernel_Size,matmul_example_A,1,UP_RIGHT_TRIU_PRESET);
	make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1, ALL1);
	make_test_matrix(Kernel_Size * NumofKernel, Panel_Size, matmul_example_C,0,ALL0);


  // Generate matrix to a file 

  //dump_matrix_file(Kernel_Size*NumofKernel, Kernel_Size, matmul_example_A, A_file, 'A');
	/*dump_matrix_file(64, 32, matmul_example_A, A_file0, 'A',4);
  //dump_matrix_file(Kernel_Size, Panel_Size, matmul_example_B, B_file, 'B');
	dump_matrix_file(32, 64, matmul_example_B, B_file0, 'B',4);
	dump_matrix_file(64, 64, matmul_example_C, C_file0, 'B',4);
*/



  //Do the Dgemm computation
  x=Global_Gemm(example1,example2,example3);


  //dump the result matrix to C
  dump_matrix_file(Kernel_Size*NumofKernel, Panel_Size, example3, C_file0, 'C',4);



	cout<< "*********************"<<endl<<endl;

	cout<<"end of matmul"<<endl;
	cout<<"Cycles="<<x <<endl;
	return 0;
}




void print_matrix(int rows, int columns, double ** matrix_A){

	int i,j;
	//cout.precision(2);

	for (i=0;i<rows;i++){
		for (j=0;j<columns;j++){
			cout<< fixed<< left  <<matrix_A[i][j]<<" , ";
      if ((i+1)%(rows/NumofKernel)==0 && j==columns-1) {
        cout<<endl;
        cout << "********************end of a matrix********************" << endl;
      }
		}
		cout<<endl;

    if (i%4==3) cout << endl;
	}


}




void dump_matrix_file(int rows, int columns, double ** matrix_A, ofstream& A_file, char type, int precision){

	int i,j;

  	A_file.precision(precision);


	A_file<<"Matrix "<<type<< "is below. With dimension "<<rows<<"x "<<columns<<endl;

	for (i=0;i<rows;i++){

		for (j=0;j<columns;j++){
			A_file<< fixed << left<<matrix_A[i][j]<<' ';
		}

    A_file<<endl;

	}

	A_file<<endl<<"****************the end****************************"<<endl;
	A_file.close();

}



int initialize_Chol_Matrix(int size, double **& matrix_A){
	int i,j,k;

	double ** temp;
	temp =(double **)  malloc ( sizeof (double *) * (size));
	matrix_A=(double **)  malloc ( sizeof (double *) * (size));

	for ( i=0; i<size; i++){
		temp[i]=(double *)  malloc ( sizeof (double ) * (size));
		matrix_A[i]=(double *)  malloc ( sizeof (double ) * (size));
		for (j=0; j<size; j++)
			temp[i][j]=(.5)*(i+j);  //TODO use random; but now just something
	}

//	cout<< "printing matrix temp"<<endl;

//	 print_matrix(size,size, temp);


	for ( i=0; i<size; i++){
		for (j=0; j<size; j++){
			for (k=0;k<size;k++){

				matrix_A[i][j]+=temp[i][k] * temp[j][k]; // tempx temptranspose
			}
		if (i==j) matrix_A[i][j]+=1;

		}
	}

//	cout<< "printing matrix A"<<endl;

//	 print_matrix(size,size, matrix_A);

}




void make_test_matrix(int rows, int columns, double **& test_matrix, int preset, Test_Matrix type){

/*
	types:

	DIAG                  : Diagonal with fixed preset
	DIAG_INCR             : Increasing diagonal with Preset
	DIAG_MULT             : Increasing diagonal with multiple of preset
	ALL0                  : All 0 matrix
	ALL1                  : All 1 matrix
  PRESET                : Constant Matrix with preset value
	UP_RIGHT_TRIU_PRESET  : Top Right aligned triangular with preset
	UP_LEFT_TRIU_PRESET   : Top Left aligned triangular with Preset	
  LO_TRIU_PRESET        : Lower triangular with preset
  BANDED                : Banded Matrix

*/
	int i,j;

	test_matrix=(double **)  malloc ( sizeof (double *) * (rows));

  if (type==DIAG) {//  diagonal with fixed preset
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
        if (i==j) test_matrix[i][j]=preset;
				else test_matrix[i][j]=0;
		}
	}

  else if (type==DIAG_INCR){  // increasing diagonal
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
        if (i==j) test_matrix[i][j]=preset+i;
				else test_matrix[i][j]=0;
		} 
  }

  else if (type==DIAG_MULT){ // increasing diagonal with multiple of preset
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
        if (i==j) test_matrix[i][j]=preset* (i+1);
				else test_matrix[i][j]=0;
		} 
  }

	
  else if (type==ALL1) {  //ALL 1 
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
			  test_matrix[i][j]=1;
		}
	}

	else if (type==ALL0) {  // ALL 0
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
      //if (rows%NumofKernel==0 && i!=0) preset++; 
			for (j=0; j<columns; j++)
				test_matrix[i][j]= 0;
		}

	}

	else if (type==PRESET) {  // ALL 0
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
      //if (rows%NumofKernel==0 && i!=0) preset++; 
			for (j=0; j<columns; j++)
				test_matrix[i][j]= preset;
		}

	}

  else if (type==UP_LEFT_TRIU_PRESET) { //Upper Triangular left aligned
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
      //if (rows%NumofKernel==0 && i!=0) preset++; 
			for (j=0; j<columns; j++){
          if (rows-i>j ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
      }
		}
  }

  else if (type==UP_RIGHT_TRIU_PRESET) { //Upper Triangular Right Alighned with preset
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
          if (j-rows>i ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
		}
  
  else if (type==LO_TRIU_PRESET) { //lower triangular with preset
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
          if (j-i<=0 ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
		}
  
	else if (type==BANDED) {// banded matrix
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++){
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				if (i==j) test_matrix[i][j]=preset+0.01*i+.0001*j;
				else if (i==(j-1)) test_matrix[i][j]=preset+0.01*i+.0001*j;
				else if (i==(j+1)) test_matrix[i][j]=preset+0.01*i+.0001*j;
				else test_matrix[i][j]=0;
			}
		}
	}

}



int Global_Chol (){

	int global_index=0;
	int Gemm_iteration_num=0; // rank_K update iteration for updating a block
	int Trsm_index=0;	// which
	int get;
	for (global_index=0; global_index< Kernel_Size / LAPU_Size ; global_index ++){

		cout<< "Global Index" << global_index << endl;


		if (global_index>0){

			if (Print_BLAS==1){
				cout<<"########################################"<<endl;
				cout<<"****************************************"<<endl;
				cout<<"RANK_D_UPDATE:"<<endl;
				cout<<"Global_index="<<global_index<<endl;
				cout<<"Trsm_index="<<global_index<<endl;
			}


			Accelerator->Rank_D_Update(global_index,global_index);
		}

		// TODO perform a Chol
		if (Print_BLAS==1){
			cout<<"########################################"<<endl;
			cout<<"****************************************"<<endl;
			cout<<"CHOLESKY:"<<endl;
			cout<<"Global_index="<<global_index<<endl;
		}

		Accelerator->Cholesky( global_index);

		for (Trsm_index= global_index+1; Trsm_index < Kernel_Size / LAPU_Size; Trsm_index ++) {   // perform Updates and consecutive Trsm


			if (global_index>0){

				if (Print_BLAS==1){
					cout<<"########################################"<<endl;
					cout<<"****************************************"<<endl;
					cout<<"RANK_D_UPDATE:"<<endl;
					cout<<"Global_index="<<global_index<<endl;
					cout<<"Trsm_index="<<Trsm_index<<endl;
				}

				Accelerator->Rank_D_Update(global_index,Trsm_index);
			}

			if (Print_BLAS==1){
				cout<<"########################################"<<endl;
				cout<<"****************************************"<<endl;
				cout<<"TRSM"<<endl;
				cout<<"Global_index="<<global_index<<endl;
				cout<<"Trsm_index="<<Trsm_index<<endl;
			}

			Accelerator->Trsm(global_index,Trsm_index);

		}

	}



	return Accelerator->Return_Cycle_Count();
}

int Global_Gemm( double **& A, double **& B, double **& C){

	int Global_index=0;
//	int Row_Block_index=0;
//	int Column_Block_index=0;

	Accelerator->Assign_input_Matrix(A,B,C);
	Accelerator->Matmul_Kernel(0);

	return Accelerator->Return_Cycle_Count();;
}

void Read_Matrix(char* type, double **& matrix, Matrix_Type mat ){

  //open file pointer
  ifstream in(type);  

  if (!in) {
      cout << "Cannot open matrix " << type <<endl;
      exit(0);
  }

  int Rows, Cols ;

  //read number of kernel
  in >> Rows;

  //read panel size
  in >> Cols;


  //create test matrix based on the kernel
  int rows = Rows;
  int columns = Cols;


  matrix=(double **)  malloc ( sizeof (double *) * (rows));
  
  for ( int i=0; i<rows; i++){
    matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
    for (int j=0; j<columns; j++){
        in>> matrix[i][j];
        //printf("matrix %d [%d][%d] = %lf\n" ,i, j, matrix[i][j]);
    }
  
  }


  in.close();
}
