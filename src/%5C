//============================================================================
// Name        : Simulator.cpp
// Author      : Ardavan Pedram
// Version     :
// Copyright   : All rights reserved for FLAME @ UTEXAS
// Description : Simulator in C++, Ansi-style
//============================================================================



//#include <iostream>
#include "Parameters.h"
#include "LAPU.h"
using namespace std;



int Global_Chol ();
int Global_Gemm( double **& A, double **& B, double **& C);
 int initialize_Chol_Matrix(int size, double **& matrix_A);
 int print_matrix(int rows, int columns, double ** matrix_A);
 int dump_matrix(int rows, int columns, double ** matrix_A, FILE *fp, char type);
int make_test_matrix(int rows, int columns, double **& test_matrix, int preset, char type);

LAPU * Accelerator;

int main(int argc, char* argv[] ) {
	cout << "!!!Hello World finally!!!" << endl; // prints !!!Hello World!!!

//	std::cout.unsetf ( std::ios::floatfield );                // floatfield not set
//	std::cout.precision(5);
	double ** example1;
	double ** example2;

	int x=0;

  char *prgName =NULL;
  char *inFile = NULL;
  char *outFile = NULL;

  int numofarg = argc;


  FILE *infp;
  FILE *infp2;
  FILE *outfp;


  /*prgName   = argv[0];
  inFile = argv[1];
  outFile = argv[2];*/

    if (numofarg!=4)
        {
          printf("Usage : <Matrix A> <Matrix B> <Matrix C> \n");
        }
        
    infp = fopen (argv[1], "wb");
    infp2 = fopen (argv[2], "wb");
    outfp = fopen (argv[3], "wb");
            
    if (infp==0)
    {          
      printf("Error, failed to open file %s \n", argv[1]);
      return 0;
    }
    
    if (infp2==0)
    {          
      printf("Error, failed to open file %s \n", argv[2]);
      return 0;
    }

    if (outfp==0)
    {           
      printf("Error, failed to open file %s \n", argv[3]);
      return 0 ;                           
    }



	Accelerator= new LAPU();


	initialize_Chol_Matrix(Kernel_Size, example1);
	make_test_matrix(Kernel_Size,Kernel_Size,example2,0,'f');
	Accelerator->Initialize_Mem(example1,Kernel_Size,Kernel_Size,0);
	if (Print_Input_Output==1)
		print_matrix(Kernel_Size,Kernel_Size,example1);

	//x=Global_Chol();

	Accelerator->Flush_Mem(example2,Kernel_Size,Kernel_Size,0);

	if (Print_Input_Output==1)
		print_matrix(Kernel_Size,Kernel_Size,example2);

	cout<<"end of program"<<endl;
	cout<<"Cycles="<<x <<endl;

	cout<<"Total FMA Dynamic Power Factor: "<< Accelerator->Return_LAPU_Power()<<endl;


// Added for testing matmul
	double ** example3;

	double ** matmul_example_A;
	double ** matmul_example_B;
	double ** matmul_example_C;



	double ** matmul_example_B1;
	double ** matmul_example_B2;



	//make_test_matrix(Kernel_Size * howmanyA ,Kernel_Size,matmul_example_A,1,'s');
	make_test_matrix(Kernel_Size * howmanyA ,Kernel_Size,matmul_example_A,1,'f');
	//make_test_matrix(Kernel_Size * howmanyA ,Kernel_Size,matmul_example_A,1,'d');

	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'^');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'s');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'l');
	make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,2,'k');
	//make_test_matrix(Kernel_Size, Panel_Size, matmul_example_B,1,'D');
	
  make_test_matrix(Kernel_Size * howmanyA, Panel_Size, matmul_example_C,0,'c');




	make_test_matrix(Kernel_Size*LAPU_Size,2*LAPU_Size,example3,0,'f');

	/*
	make_test_matrix(Kernel_Size*LAPU_Size,2*LAPU_Size,example3,0);

	make_test_matrix(Kernel_Size*LAPU_Size,LAPU_Size,matmul_example_B1,1);
	make_test_matrix(Kernel_Size*LAPU_Size,LAPU_Size,matmul_example_B2,-1);
*/
//	Accelerator->Initialize_Mem(matmul_example_A,Kernel_Size,Kernel_Size,0);


	//Accelerator->Initialize_Mem(matmul_example_B,Kernel_Size*LAPU_Size,LAPU_Size,
	//TODO					(Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size));

/*	Accelerator->Initialize_Mem(matmul_example_B1,Kernel_Size*LAPU_Size,LAPU_Size,
						(Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size));

	Accelerator->Initialize_Mem(matmul_example_B2,Kernel_Size*LAPU_Size,LAPU_Size,
							(Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size)+Kernel_Size);
*/
  // Generate matrix to a file 

  dump_matrix(Kernel_Size*howmanyA, Kernel_Size, matmul_example_A, infp, 'A');
  dump_matrix(Kernel_Size, Panel_Size, matmul_example_B, infp2, 'B');

	print_matrix(Kernel_Size*howmanyA ,Kernel_Size,matmul_example_A);

	getchar();
  
  cout << "BBBBBBBBBBBBBBB" <<endl;

  print_matrix(Kernel_Size, Panel_Size,matmul_example_B);

	getchar();
	
  x=Global_Gemm(matmul_example_A,matmul_example_B,matmul_example_C);

  dump_matrix(Kernel_Size*howmanyA, Panel_Size, matmul_example_C, outfp, 'C');

	cout<< "AAAAAAAAAAAAAAAAAAAAAAA"<<endl<<endl;

	Accelerator->Flush_Mem_New(matmul_example_A,Kernel_Size*NumofA,Kernel_Size,0, 'A');
	print_matrix(Kernel_Size*howmanyA,Kernel_Size,matmul_example_A);

	getchar();
	/*cout<< "CCCCCCCCCCCCCCCCCCCCC"<<endl<<endl;

	Accelerator->Flush_Mem(example3,Kernel_Size*LAPU_Size,2*LAPU_Size,(Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size));
	print_matrix(Kernel_Size*LAPU_Size,2*LAPU_Size,example3);*/

//	Accelerator->Flush_Mem(example3,Kernel_Size*LAPU_Size,2*LAPU_Size,(Kernel_Size*Kernel_Size)/(LAPU_Size*LAPU_Size));
	cout<< "*********************"<<endl<<endl;

    print_matrix(Kernel_Size*howmanyA, Panel_Size,matmul_example_C);

//
	cout<<"end of matmul"<<endl;
	cout<<"Cycles="<<x <<endl;
	return 0;
}

int print_matrix(int rows, int columns, double ** matrix_A){

	int i,j;
	cout.precision(2);

	for (i=0;i<rows;i++){
		for (j=0;j<columns;j++){
			cout<< fixed<< left  <<matrix_A[i][j]<<" , ";
      if ((i+1)%(rows/howmanyA)==0 && j==columns-1) {
        cout<<endl;
        cout << "********************end of a matrix********************" << endl;
      }
		}
		cout<<endl;

    if (i%4==3) cout << endl;
	}


}

int dump_matrix(int rows, int columns, double ** matrix_A, FILE *infp, char type){

	int i,j;
	cout.precision(2);

  fprintf(infp, " Matrix %c is below. Size is %d X %d \n **********\n",type, rows, columns );
    
	for (i=0;i<rows;i++){
    
    //fprintf(infp,"row #%d: ", i);
		for (j=0;j<columns;j++){
      fprintf(infp,"%.2f ,", matrix_A[i][j]);
			//cout<< fixed<< left  <<matrix_A[i][j]<<" , ";  
		}
    
    fprintf(infp,"\n");

	}
  fprintf(infp, "\n****************the end****************************\n");
  fclose(infp);

}

int initialize_Chol_Matrix(int size, double **& matrix_A){
	int i,j,k;

	double ** temp;
	temp =(double **)  malloc ( sizeof (double *) * (size));
	matrix_A=(double **)  malloc ( sizeof (double *) * (size));

	for ( i=0; i<size; i++){
		temp[i]=(double *)  malloc ( sizeof (double ) * (size));
		matrix_A[i]=(double *)  malloc ( sizeof (double ) * (size));
		for (j=0; j<size; j++)
			temp[i][j]=(.5)*(i+j);  //TODO use random; but now just something
	}

//	cout<< "printing matrix temp"<<endl;

//	 print_matrix(size,size, temp);


	for ( i=0; i<size; i++){
		for (j=0; j<size; j++){
			for (k=0;k<size;k++){

				matrix_A[i][j]+=temp[i][k] * temp[j][k]; // tempx temptranspose
			}
		if (i==j) matrix_A[i][j]+=1;

		}
	}

//	cout<< "printing matrix A"<<endl;

//	 print_matrix(size,size, matrix_A);

}




int make_test_matrix(int rows, int columns, double **& test_matrix, int preset, char type){

	int i,j;


	test_matrix=(double **)  malloc ( sizeof (double *) * (rows));


	if (type=='d') {// diagonal
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				if (i==j || (i%(rows/howmanyA))==j) test_matrix[i][j]=i+1;
				else test_matrix[i][j]=0;//*(-1)^(j%2);
		}
	}
	
  if (type=='c') {// diagonal for c
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
			  test_matrix[i][j]=preset;
		}
	}
	//print_matrix(8,8,test_matrix);

	//print_matrix(8,8,test_matrix);

	else if (type=='f') {
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
      //if (rows%howmanyA==0 && i!=0) preset++; 
			for (j=0; j<columns; j++)
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				test_matrix[i][j]= i+1;//*(-1)^(j%2);
      //preset++;
		}

	}
	
  else if (type=='g') { //all one set for B
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
      //if (rows%howmanyA==0 && i!=0) preset++; 
			for (j=0; j<columns; j++)
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				test_matrix[i][j]= preset;//i+1;//*(-1)^(j%2);
      //preset++;
		}
  }

	/*else if (type=='s') {// smart full
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++)
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				test_matrix[i][j]=i+1;//(-1)^(j%2);
		}
	}*/
	
  else if (type=='s') {
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					//if (i==j ) test_matrix[i][j]=i+1;
          if (j-i<=0 ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
		}
  
  else if (type=='l') {
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					//if (i==j ) test_matrix[i][j]=i+1;
          if (rows-i>j ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
		}
  
  else if (type=='k') {
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					//if (i==j ) test_matrix[i][j]=i+1;
          if (rows-1-i<=j /*&& j<Panel_Size/2*/) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
    }

	else if (type=='b') {// banded
		for ( i=0; i<rows; i++){
			test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
			for (j=0; j<columns; j++){
				//test_matrix[i][j]=(preset*100)+i+ .01*j;
				if (i==j) test_matrix[i][j]=preset+0.01*i+.0001*j;
				else if (i==(j-1)) test_matrix[i][j]=preset+0.01*i+.0001*j;
				else if (i==(j+1)) test_matrix[i][j]=preset+0.01*i+.0001*j;
				//else test_matrix[i][j]=0+0.01*i+.0001*j;
				else test_matrix[i][j]=0;
			}
		}
	}

	else if (type=='^') {// banded
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					//if (i==j ) test_matrix[i][j]=i+1;
          if (j-i>=0 ) test_matrix[i][j] = preset;
					else test_matrix[i][j]=0;
				}
			}
		}

	else if (type=='D') {
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					if (i==j) test_matrix[i][j]=i+1;
					else test_matrix[i][j]=0;
				}
			}
		}
	
  else if (type=='t') {
      int mul=1;
			for ( i=0; i<rows; i++){
				test_matrix[i]=(double *)  malloc ( sizeof (double ) * (columns));
				if (i>=(rows/howmanyA) && !(i%(rows/howmanyA))) {
          mul++;
          //cout << "rows per howmanyA is "<< rows/howmanyA << endl;
          //cout << "i is " << i << endl;
          //getchar();
        }
        for (j=0; j<columns; j++){
					//test_matrix[i][j]=(preset*100)+i+ .01*j;
					if (i==j) test_matrix[i][j]=j+1 ;
          else if (i>=(rows/howmanyA) && i%(rows/howmanyA)==j) {
            test_matrix[i][j] = (j+1) * mul /*(i-32)+1 + 0.01*(j+1)*/;
          }
          else test_matrix[i][j]=0;
				}
			}
		}
}



int Global_Chol (){

	int global_index=0;
	int Gemm_iteration_num=0; // rank_K update iteration for updating a block
	int Trsm_index=0;	// which
	int get;
	for (global_index=0; global_index< Kernel_Size / LAPU_Size ; global_index ++){

		cout<< "Global Index" << global_index << endl;


		if (global_index>0){

			if (Print_BLAS==1){
				cout<<"########################################"<<endl;
				cout<<"****************************************"<<endl;
				cout<<"RANK_D_UPDATE:"<<endl;
				cout<<"Global_index="<<global_index<<endl;
				cout<<"Trsm_index="<<global_index<<endl;
			}


			Accelerator->Rank_D_Update(global_index,global_index);
		}

		// TODO perform a Chol
		if (Print_BLAS==1){
			cout<<"########################################"<<endl;
			cout<<"****************************************"<<endl;
			cout<<"CHOLESKY:"<<endl;
			cout<<"Global_index="<<global_index<<endl;
		}

		Accelerator->Cholesky( global_index);

		for (Trsm_index= global_index+1; Trsm_index < Kernel_Size / LAPU_Size; Trsm_index ++) {   // perform Updates and consecutive Trsm


			if (global_index>0){

				if (Print_BLAS==1){
					cout<<"########################################"<<endl;
					cout<<"****************************************"<<endl;
					cout<<"RANK_D_UPDATE:"<<endl;
					cout<<"Global_index="<<global_index<<endl;
					cout<<"Trsm_index="<<Trsm_index<<endl;
				}

				Accelerator->Rank_D_Update(global_index,Trsm_index);
			}

			if (Print_BLAS==1){
				cout<<"########################################"<<endl;
				cout<<"****************************************"<<endl;
				cout<<"TRSM"<<endl;
				cout<<"Global_index="<<global_index<<endl;
				cout<<"Trsm_index="<<Trsm_index<<endl;
			}

			Accelerator->Trsm(global_index,Trsm_index);

		}

	}



	return Accelerator->Return_Cycle_Count();
}

int Global_Gemm( double **& A, double **& B, double **& C){

	int Global_index=0;
//	int Row_Block_index=0;
//	int Column_Block_index=0;

	Accelerator->Assign_input_Matrix(A,B,C);
	Accelerator->Matmul_Kernel(0);

	return Accelerator->Return_Cycle_Count();;
}

