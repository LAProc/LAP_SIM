/*
 * LAPU.cpp
 *
 *  Created on: Mar 4, 2010
 *      Author: ardavan
 */

#include "LAPU.h"

using namespace std;

LAPU::LAPU()
{
	// TODO Auto-generated constructor stub


	Cycles_Passed=0;
	Counter_Curr=0;
	Counter_Next=1;

	Mc_Counter_Curr=0;
	Mc_Counter_Next=0;

	Kc_Counter_Curr=0;
	Kc_Counter_Next=0;

	N_Counter_Curr=0;
	N_Counter_Next=0;

  Last_Sending = -2; //considering bus delay
  done = false;

  //Last_Sending = 0;


	State_Start= FALSE;

	Size=LAPU_Size;

	Row_Buses_Read= (double *) malloc (sizeof (double) * LAPU_Size);
	Column_Buses_Read= (double *) malloc (sizeof (double) * LAPU_Size);
	Row_Buses_Write= (double *) malloc (sizeof (double) * LAPU_Size);
	Column_Buses_Write= (double *) malloc (sizeof (double) * LAPU_Size);

	PE_Array =(PE **)  malloc ( sizeof (PE *) * (LAPU_Size));
	int i,j;
	for ( i=0; i<Size; i++){
		PE_Array[i]=(PE *)  malloc ( sizeof (PE ) * (LAPU_Size));
		for (j=0; j<Size; j++)
			PE_Array[i][j]= *new PE(i,j, &Row_Buses_Write[i],&Row_Buses_Read[i],
										&Column_Buses_Write[j],&Column_Buses_Read[j]);
	}

	 Sqrt_Unit= new Inv_Sqrt(Row_Buses_Write, Row_Buses_Read, Column_Buses_Write, Column_Buses_Read);
		cout<< "in lapu const"<<endl;

	Mem_IF= new IO(Row_Buses_Write, Row_Buses_Read, Column_Buses_Write, Column_Buses_Read);

	LAPU_Power_Consumed=0;
}



LAPU::~LAPU()
{
	// TODO Auto-generated destructor stub
}

int LAPU::Return_Cycle_Count(){
	return Cycles_Passed;
}
int LAPU::Initialize_Mem( double ** Input_matrix, int row_number, int column_number, int offset){

	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			PE_Array[i][j].Intialize_Local_Mem(Input_matrix,row_number,column_number, offset);

		}


}

int LAPU::Initialize_Mem_New( double ** Input_matrix, int row_number, int column_number, int offset, char matr){

	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			PE_Array[i][j].Initialize_Local_Mem_New(Input_matrix,row_number,column_number, offset, matr);

		}
}

int LAPU::Flush_Mem( double **& Input_matrix, int row_number, int column_number,int offset){

	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			PE_Array[i][j].Flush_Local_Mem(Input_matrix,row_number,column_number, offset);

		}
}

int LAPU::Flush_Mem_New( double **& Input_matrix, int row_number, int column_number,int offset, char matr){

	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			PE_Array[i][j].Flush_Local_Mem_New(Input_matrix,row_number,column_number, offset, matr);

		}
}


int LAPU::Assign_input_Matrix( double **& matrix_A, double **& matrix_B, double **& matrix_C){

	Matrix_A=matrix_A;
	Matrix_B=matrix_B;
	Matrix_C=matrix_C;

	Mem_IF->Assign_input_Matrix(matrix_A, matrix_B, matrix_C);
}




int LAPU::Return_LAPU_Power(){


	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			LAPU_Power_Consumed+=PE_Array[i][j].Return_PE_Power();
		}

	return LAPU_Power_Consumed;

}


int LAPU::Dump_Row_Buses(){

	cout<<"Row_Bus_Write  And ROw Bus Read :"<<endl;

	for (i=0; i <LAPU_Size;i++){
		cout<<"-"<<i<<":"<< Row_Buses_Write[i]<<"  ";
		cout<<""<< Row_Buses_Read[i]<<endl;
	}
	cout<<"****"<<endl;

}


int LAPU::Dump_Column_Buses(){

	cout<< "Column Bus Write"<<endl;
	cout<< "Column Bus Read"<<endl;

	for (i=0; i <LAPU_Size;i++)
		cout<<i<<"| : ";
	cout<<endl;

	for (i=0; i <LAPU_Size;i++)
			cout<<Column_Buses_Write[i]<<" , ";
	cout<<endl;
	for (i=0; i <LAPU_Size;i++)
		cout<<Column_Buses_Read[i]<<" , ";

	cout<<endl;


	cout<<"****"<<endl;


}


int LAPU::Dump_Trsm_SMachine(){


	cout<<"Iteration :"<< Counter_Curr<<endl;
	cout<<" \t State:"<<endl;
	switch (Trsm_Current_State){

		case Trsm_Initial:

			cout<<"Trsm_Initial"<<endl;
		break;


		case Trsm_BC_InvSqrt:

			cout<<"Trsm_BC_InvSqrt"<<endl;
		break;

		case Trsm_Multiply:
			cout<<"Trsm_Multiply"<<endl;
		break;

		case Trsm_BC_Mult:
			cout<<"Trsm_BC_Mult"<<endl;
		break;

		case Trsm_Partial_Rank_1:
			cout<<"Trsm_Partial_Rank_1"<<endl;
		break;

		case Trsm_End:
			cout<<"Trsm_End"<<endl;
		break;

	}
	cout<<"Latency_Count ="<<Latency_Counter_Curr<<endl;

	switch (Trsm_Next_State){

		case Trsm_Initial:

			cout<<"Trsm_Initial"<<endl;
		break;


		case Trsm_BC_InvSqrt:

			cout<<"Trsm_BC_InvSqrt"<<endl;
		break;

		case Trsm_Multiply:
			cout<<"Trsm_Multiply"<<endl;
		break;

		case Trsm_BC_Mult:
			cout<<"Trsm_BC_Mult"<<endl;
		break;

		case Trsm_Partial_Rank_1:
			cout<<"Trsm_Partial_Rank_1"<<endl;
		break;

		case Trsm_End:
			cout<<"Trsm_End"<<endl;
		break;

	}


	cout<<endl;


}



int LAPU::Dump_Chol_SMachine(){
	cout<<"Iteration :"<< Counter_Curr<<endl;
	cout<<"State:"<<endl;
	switch (Chol_Current_State){

		case Chol_Initial:
			cout<<"Chol_Initial"<<endl;
		break;


		case Chol_Feed_Sqrt:
			cout<<" Chol_Feed_Sqrt"<<endl;

		break;

		case Chol_Inv_Sqrt:
			cout<<" Chol_Inv_Sqrt"<<endl;

		break;

		case Chol_BC_InvSqrt:
			cout<<" Chol_BC_InvSqrt"<<endl;

		break;

		case Chol_Multiply:
			cout<<" Chol_Multiply"<<endl;

		break;

		case Chol_BC_Mul:
			cout<<" Chol_BC_Mul"<<endl;

		break;

		case Chol_Rank1_Update:
			cout<<" Chol_Rank1_Update"<<endl;

		break;

		case Chol_End:
			cout<<" Chol_End"<<endl;

		break;


	}
	cout<<"Latency_Count ="<<Latency_Counter_Curr<<endl;

	/*
	switch (Chol_Next_State){

		case Chol_Initial:
			cout<<" Chol_Initial"<<endl;
		break;


		case Chol_Feed_Sqrt:
			cout<<"Nextt_State=Chol_Feed_Sqrt"<<endl;

		break;

		case Chol_Inv_Sqrt:
			cout<<"Nextt_State=Chol_Inv_Sqrt"<<endl;

		break;

		case Chol_BC_InvSqrt:
			cout<<"Nextt_State=Chol_BC_InvSqrt"<<endl;

		break;

		case Chol_Multiply:
			cout<<" Chol_Multiply"<<endl;

		break;

		case Chol_BC_Mul:
			cout<<" Chol_BC_Mul"<<endl;

		break;

		case Chol_Rank1_Update:
			cout<<"Chol_Rank1_Update"<<endl;

		break;

		case Chol_End:
			cout<<" Chol_End"<<endl;

		break;



	}

*/


	cout<<endl;

}


int LAPU::Dump_Gemm_SMachine(){

	cout<<"Iteration :"<< Counter_Curr<<endl;
	cout<<"State:"<<endl;
	switch (Gemm_Current_State){

		case Gemm_Initial:
			cout<<" Gemm_Initial"<<endl;
		break;


		case Gemm_Pre_Fetch:
			cout<<" Gemm_Pre_Fetch"<<endl;

		break;

		case Gemm_BC:
			cout<<" Gemm_BC"<<endl;

		break;

		case Gemm_MAC_BC:
			cout<<" Gemm_MAC_BC"<<endl;

		break;

		case Gemm_MAC:
			cout<<" Gemm_MAC"<<endl;

		break;

		case Gemm_End:
			cout<<" Gemm_End"<<endl;

		break;


	}

	cout<<"Latency_Count ="<<Latency_Counter_Curr<<endl;
	switch (Gemm_Next_State){

		case Gemm_Initial:
			cout<<" Gemm_Initial"<<endl;
		break;


		case Gemm_Pre_Fetch:
			cout<<" Gemm_Pre_Fetch"<<endl;

		break;

		case Gemm_BC:
			cout<<" Gemm_BC"<<endl;

		break;

		case Gemm_MAC_BC:
			cout<<" Gemm_MAC_BC"<<endl;

		break;

		case Gemm_MAC:
			cout<<" Gemm_MAC"<<endl;

		break;

		case Gemm_End:
			cout<<" Gemm_End"<<endl;

		break;

	}




	cout<<endl;

}


int LAPU::Dump_Matmul_SMachine(){

	cout<<"N :"<< N_Counter_Curr<<endl;
	cout<<"Mc"<<Mc_Counter_Curr<<endl;
	cout<<"Kc"<<Kc_Counter_Curr<<endl;

	switch (Matmul_Current_State){

		case Matmul_Init:
			cout<<" Matmul_Init"<<endl;
		break;


		case Matmul_FetchB:
			cout<<" Matmul_FetchB"<<endl;

		break;

		case Matmul_FetchA:
			cout<<" Matmul_FetchA"<<endl;

		break;

		case Matmul_BC0:
			cout<<" Matmul_BC0"<<endl;

		break;

		case Matmul_BC:
			cout<<" Matmul_BC"<<endl;

		break;

		case Matmul_MAC_BC:
			cout<<" Matmul_MAC_BC"<<endl;

		break;

		case Matmul_MAC_Flush:
			cout<<" Matmul_MAC_FLush"<<endl;

		break;

		case Matmul_End:
			cout<<" Matmul_End"<<endl;

		break;


	}

	cout<<"Latency_Count ="<<Latency_Counter_Curr<<endl;


	switch (Matmul_Next_State){

		case Matmul_Init:
			cout<<" Matmul_Init"<<endl;
		break;


		case Matmul_FetchB:
			cout<<" Matmul_FetchB"<<endl;

		break;

		case Matmul_FetchA:
			cout<<" Matmul_FetchA"<<endl;

		break;

		case Matmul_BC0:
			cout<<" Matmul_BC0"<<endl;

		break;

		case Matmul_BC:
			cout<<" Matmul_BC"<<endl;

		break;

		case Matmul_MAC_BC:
			cout<<" Matmul_MAC_BC"<<endl;

		break;
		case Matmul_MAC_Flush:
			cout<<" Matmul_MAC_FLush"<<endl;

		break;

		case Matmul_End:
			cout<<" Matmul_End"<<endl;

		break;

	}




	cout<<endl;

}





int LAPU::Dump_PE_Registers(int row, int column){


 PE_Array[row][column].Dump_Regs();

}


int LAPU::Dump_All_PE_Registers(){


	for (i=0;i<LAPU_Size;i++)
		for (j=0;j<LAPU_Size;j++)
			 PE_Array[i][j].Dump_Regs();

}



int LAPU::Dump_PE_ALU(int row, int column, ALU_op operation_type){

	 PE_Array[row][column].Dump_ALU_Pipeline( operation_type);
}

int LAPU::Dump_All_PE_ALUs(ALU_op operation_type){

	for (i=0;i<LAPU_Size;i++)
		for (j=0;j<LAPU_Size;j++)
			 PE_Array[i][j].Dump_ALU_Pipeline( operation_type);
}

int LAPU::Dump_Sqrt_Unit(){


	Sqrt_Unit->Dump_Inv_Sqrt_Regs();

}



int LAPU::Cycle(){



//	int i,j;
	for (i=0;i<Size;i++)
		for (j=0;j<Size;j++){
			PE_Array[i][j].Cycle();
		}
	Sqrt_Unit->Cycle();

	Counter_Curr=Counter_Next;
	Latency_Counter_Curr=Latency_Counter_Next;

	Mc_Counter_Curr=Mc_Counter_Next;

	Kc_Counter_Curr=Kc_Counter_Next;

	N_Counter_Curr=N_Counter_Next;

  Ma_Counter_Curr = Ma_Counter_Next;

	Chol_Current_State=Chol_Next_State;
	Trsm_Current_State=Trsm_Next_State;
	Gemm_Current_State=Gemm_Next_State;
	Matmul_Current_State=Matmul_Next_State;

	Cycles_Passed++;
}

int LAPU::Drive_Buses(){

	for (i=0; i<LAPU_Size ; i++){
		Row_Buses_Read[i]=Row_Buses_Write[i];
		Column_Buses_Read[i]=Column_Buses_Write[i];

	}

	return 0;
}

int LAPU::Cholesky(int Global_index){



	while (1){


		switch (Chol_Current_State) {// TODO comment

			case Chol_Initial: // Read from Local Memory put it on the bus
				Chol_Next_State= Chol_Feed_Sqrt;
				Latency_Counter_Next=0;
				Latency_Counter_Curr=0;
				Counter_Curr=0;
				Counter_Next=0;
				State_Start=FALSE;


			break;

			case Chol_Feed_Sqrt: // transfer the data to Sqrt Unit  //TODO now I assume it is one clock latency
				Chol_Next_State=Chol_Inv_Sqrt;




				Latency_Counter_Next=0;
				Latency_Counter_Curr=0;
				State_Start=FALSE;

			break;

			case Chol_Inv_Sqrt: // start Sqrt

				if (Latency_Counter_Curr== 0){

					State_Start=TRUE;
					// Give the Data to the Sqrt unit
					//	PE_Array[Counter_Curr][Counter_Curr].Gen_Address(Global_index, Counter_Curr);
						//more to do maybe;

					}
				// I have to drive bus before calling this
					//InvSqrt.Inv_Sqrt_Execute(.5);
					//TODO here do I invoke Inv Sqrt all the time ? (I do but I do not invoke it other times) (Sqrt himself knows that he is sleep :D)
				Latency_Counter_Next=Latency_Counter_Curr+1;

				if (Latency_Counter_Curr < (InvSqrt_Latency -1)) {
					State_Start=FALSE;
					Chol_Next_State= Chol_Inv_Sqrt;
				}
				else {
					State_Start=FALSE;

					Chol_Next_State= Chol_BC_InvSqrt;
					Latency_Counter_Next=0;
				}

			break;

			case Chol_BC_InvSqrt: //TODO:for now BC delay is one Cycle

				//cout<<Chol_BC_InvSqrt<<endl;
				// Some signals should be sent to PE[Counter_Curr][Counter_Curr]
				// Still depends on the broad_cast delay if we loop back to this state or not

				//Send Counter_Curr and Chol_BC to all PEs

				Chol_Next_State= Chol_Multiply;
				Latency_Counter_Next=0;

			break;



			case Chol_Multiply:

				// Serious question: do I call Mul each cycle or
				//just once in the beginning and let the functions return after   delay cycle?
				// this decision should be uniform for Rank-K updates too

				//: the answer to previous question . I do not call PE.MUl I just have an Execute function for PEs.
				// All PEs are informed what State LAPU is in and how much latency has passed and all valuable info (See Execute arguments)
				// In each clock Execute is called at the end of this state machine code below here. PEs produce their signals and decide if they are dead or alive
				//based on the arguments that they get.
				// LAPU state machine plus its latency counter  has cycle accurate info that passes to PEs and they work with this info and produce needed control signals



				if (Latency_Counter_Curr==0){

					State_Start=TRUE;
					/*for (i=0;i<Size;i++)
						for (j=0;j<Size;j++){
						//	PE_Array[i][j].Multiply();
						}
					*/

				}
				Latency_Counter_Next=Latency_Counter_Curr+1;

				if (Latency_Counter_Curr < (Multiplication_Latency-1)){
					State_Start=FALSE;
					Chol_Next_State=Chol_Multiply;

				}
				else{

					if (Counter_Curr< (LAPU_Size-1)){  //TODO: Maybe (LAPU_Size -1)
						State_Start=FALSE;
						Chol_Next_State= Chol_BC_Mul;
//						Counter_Next=Counter_Curr+1;
						Latency_Counter_Next=0;
					}
					else Chol_Next_State= Chol_End; // start is already False

				}

			break;


			case Chol_BC_Mul:

				//Again Some of the PEs are dead and some others are alive here
				//Do I selectively call their functions or just set signals
				//and call all PEs uniformly out of the state machine ?
				// Answer: I set signals (I do not even set any signal I give general info to them (See PE.Execute Arguments)
								//and call all PEs uniformly out of the state machine ?

				Chol_Next_State= Chol_Rank1_Update;
				Latency_Counter_Next=0;

			break;

			case Chol_Rank1_Update:

				//Same scenario here;
				if (Latency_Counter_Curr==0){

					State_Start=TRUE; //maybe I even can get rid of this since I have the latency counter passed to PEs
									 // for readability I will keep it though

					/*for (i=0;i<Size;i++)
							for (j=0;j<Size;j++){
								//PE_Array[i][j].Rank_Update(); // start or continue ?
								//: I just say when is the start :D and I call everybody all the times
							}
						*/
				}

				Latency_Counter_Next=Latency_Counter_Curr +1;

				if (Latency_Counter_Curr< (FMA_Latency-1)){
						State_Start=FALSE;
						Chol_Next_State=Chol_Rank1_Update;
				}
				else { // in this case we are certainly in the first 3 iterations so we directly  go to Feed_Sqrt

							State_Start=FALSE;
							Chol_Next_State= Chol_Feed_Sqrt;
							Counter_Next=Counter_Curr+1;
							Latency_Counter_Next=0;


				}

			break;

			case Chol_End:
				Counter_Next=0;
				Counter_Curr=0;
			//	return Cycles_Passed;


		}  //switch-case


		// DO I Call Functions in the state machine or I just set signals and then Here I pass them to Live PEs?
		//: Answer: Everybody is alive here below
		if (Print_State_Machines==1){
			cout<<"==============================";
			cout<<"Cycle"<<Cycles_Passed<<endl;

			Dump_Chol_SMachine();
		}

		for (i=0;i<Size;i++)
			for (j=0;j<Size;j++){
				PE_Array[i][j].Execute(Global_index, 0, Counter_Curr, Latency_Counter_Curr,
											LAPU_Cholesky, Chol_Current_State, State_Start );  // We pass this Routine an the current state of this routine to PE
			}

		Sqrt_Unit->Execute(Global_index, Counter_Curr, Latency_Counter_Curr,
				LAPU_Cholesky, Chol_Current_State, State_Start );


		 if (Chol_Current_State==Chol_End){
			 Chol_Current_State=Chol_Initial;
			 Chol_Next_State=Chol_Initial;
			 return Cycles_Passed;
		 }

		//Dump_Row_Buses();
		//Dump_Column_Buses();

	//	if ( (Chol_Current_State==Chol_Inv_Sqrt) || (Chol_Current_State==Chol_BC_InvSqrt))
	//		Sqrt_Unit->Dump_Inv_Sqrt_Regs();
		Drive_Buses(); // Can it be a part of Cycle function? I remember I just seperated it for readability
		// It does not matter which one comes first Drive_Bus or Cycle;

		Cycle();


			// Drive Bus

	}






}




int LAPU::Trsm(int Global_index, int Trsm_index){

	while (1){

		switch (Trsm_Current_State){


			case Trsm_Initial:

				Trsm_Next_State=Trsm_Multiply;
				Latency_Counter_Next=0;
				Latency_Counter_Curr=0;
				State_Start=FALSE;
				Counter_Curr=0;
				Counter_Next=0;

			break;


			case Trsm_Multiply:

				if (Latency_Counter_Curr== 0){

						State_Start=TRUE;

				}

				Latency_Counter_Next=Latency_Counter_Curr+1;

				if (Latency_Counter_Curr < (Multiplication_Latency-1)) {
					State_Start=FALSE;
					Trsm_Next_State= Trsm_Multiply;

				}
				else {

					State_Start=FALSE;
					Trsm_Next_State= Trsm_BC_Mult;
					Latency_Counter_Next=0;
/*
					if (Counter_Curr< (LAPU_Size-1)){  //TODO: Maybe (LAPU_Size -1)
						State_Start=FALSE;
						Trsm_Next_State= Trsm_BC_Mult;
						Latency_Counter_Next=0;
					}
					else Trsm_Next_State= Trsm_End; // start is already False
*/
				}

			break;


			case Trsm_BC_Mult:

				if (Counter_Curr< (LAPU_Size-1))
					Trsm_Next_State= Trsm_Partial_Rank_1;
				else
					Trsm_Next_State=Trsm_Trans;

				Latency_Counter_Next=0;



			break;


			case Trsm_Partial_Rank_1:

				if (Latency_Counter_Curr==0){

					State_Start=TRUE; //maybe I even can get rid of this since I have the latency counter passed to PEs
									 // for readability I will keep it though

					/*for (i=0;i<Size;i++)
							for (j=0;j<Size;j++){
								//PE_Array[i][j].Rank_Update(); // start or continue ?
								//: I just say when is the start :D and I call everybody all the times
							}
						*/
				}

				Latency_Counter_Next=Latency_Counter_Curr +1;

				if (Latency_Counter_Curr< (FMA_Latency-1)){
						State_Start=FALSE;
						Trsm_Next_State=Trsm_Partial_Rank_1;
				}
				else { // in this case we are certainly in the first 3 iterations so we directly  go to Feed_Sqrt

							State_Start=FALSE;
							Trsm_Next_State= Trsm_Multiply;
							Counter_Next=Counter_Curr+1;
							Latency_Counter_Next=0;


				}




			break;


			case Trsm_Trans:

				Latency_Counter_Next=Latency_Counter_Curr +1;

				if (Latency_Counter_Curr==0)
					Trsm_Next_State=Trsm_Trans;
				else{
					Trsm_Next_State=Trsm_End;
					Latency_Counter_Next=0;
				}

			break;


			case Trsm_End:
				Counter_Next=0;
				Counter_Curr=0;

				//return Cycles_Passed;

			break;



		}

		if (Print_State_Machines==1){
			cout<<"==============================";
			cout<<"Cycle"<<Cycles_Passed<<endl;
		//	char test2;
		//	cout<<"Press Enter"<<endl;
		//	cin>>test2;
			Dump_Trsm_SMachine();
		}

		for (i=0;i<Size;i++)
			for (j=0;j<Size;j++){
				PE_Array[i][j].Execute(Global_index, Trsm_index, Counter_Curr, Latency_Counter_Curr,
											LAPU_Trsm, Trsm_Current_State, State_Start );  // We pass this Routine an the current state of this routine to PE
			}

		Sqrt_Unit->Execute(Global_index, Counter_Curr, Latency_Counter_Curr,
				LAPU_Trsm, Trsm_Current_State, State_Start );
	//	Dump_Row_Buses();
	//	Dump_Column_Buses();

		if (Trsm_Current_State==Trsm_End){
				 Trsm_Current_State=Trsm_Initial;
				 Trsm_Next_State=Trsm_Initial;
				 return Cycles_Passed;
			 }

		Drive_Buses(); // Can it be a part of Cycle function? I remember I just seperated it for readability
		// It does not matter which one comes first Drive_Bus or Cycle;

		Cycle();






	}


}




int LAPU::Rank_D_Update(int Global_index, int Trsm_index){


	while (1){

		switch (Gemm_Current_State){

			case Gemm_Initial:



				Gemm_Next_State=Gemm_Pre_Fetch;
				Latency_Counter_Next=0;
				Latency_Counter_Curr=0;
				State_Start=TRUE;


			break;

			case Gemm_Pre_Fetch:

				Latency_Counter_Next=Latency_Counter_Curr +1;
				if (Latency_Counter_Curr==0){
					Gemm_Next_State=Gemm_Pre_Fetch;
					State_Start=TRUE;
				}
				else{
					Gemm_Next_State=Gemm_BC;
					State_Start=FALSE;
					Latency_Counter_Next=0;
				}



			break;

			case Gemm_BC:


				Gemm_Next_State= Gemm_MAC_BC;
				Latency_Counter_Next=0;
				Counter_Next=Counter_Curr+1;

			break;

			case Gemm_MAC_BC:




				if (Latency_Counter_Curr==0){

					State_Start=TRUE;

				}

				//Latency_Counter_Next=Latency_Counter_Curr +1;



				//if (Latency_Counter_Curr< (FMA_Latency-1)){
				//		State_Start=FALSE;
				//		Gemm_Next_State=Gemm_MAC_BC;
				//}
				//else {

				//	Latency_Counter_Next=0;
					Counter_Next=Counter_Curr+1;
					if (Counter_Curr <  ( ( (Global_index)* LAPU_Size ) -1) ){
						Gemm_Next_State=Gemm_MAC_BC;

					}
					else{
						Gemm_Next_State=Gemm_MAC;
						Counter_Next=0;

					}

			//	}


			break;

			case Gemm_MAC:

				Latency_Counter_Next=Latency_Counter_Curr+1;

				if (Latency_Counter_Curr< (FMA_Latency-1))
					Gemm_Next_State=Gemm_MAC;
				else{
					Gemm_Next_State=Gemm_End;
					Latency_Counter_Next=0;
				}
			break;


			case Gemm_End:

				Counter_Next=0;
				Counter_Curr=0;


			break;


		}

		if (Print_State_Machines==1){
			cout<<"==============================";
			cout<<"Cycle"<<Cycles_Passed<<endl;
		//	char test2;
		//	cout<<"Press Enter"<<endl;
		//	cin>>test2;
			Dump_Gemm_SMachine();
		}
		for (i=0;i<Size;i++)
			for (j=0;j<Size;j++){
				PE_Array[i][j].Execute(Global_index, Trsm_index, Counter_Curr, Latency_Counter_Curr,
						LAPU_Rank_Update, Gemm_Current_State, State_Start );  // We pass this Routine an the current state of this routine to PE
			}

		Sqrt_Unit->Execute(Global_index, Counter_Curr, Latency_Counter_Curr,
				LAPU_Rank_Update, Gemm_Current_State, State_Start ); // TODO fix the input;

		 if (Gemm_Current_State==Gemm_End){
			 Gemm_Current_State=Gemm_Initial;
			 Gemm_Next_State=Gemm_Initial;
			 return Cycles_Passed;
		 }
	//	Dump_Row_Buses();
	//	Dump_Column_Buses();

		Drive_Buses(); // Can it be a part of Cycle function? I remember I just seperated it for readability
		// It does not matter which one comes first Drive_Bus or Cycle;

		Cycle();


	}


}



/*

int LAPU::Matmul_Rank_D(int Global_index){


	while (1){

		switch(MatMul_Current_State){

//		case







		}








	}

}


*/


int LAPU::Matmul_Kernel(int Global_index){

	while (1){

			switch (Matmul_Current_State){

				case Matmul_Init:

					Kc_Counter_Next=(Kc_Counter_Curr+1);
					if (Kc_Counter_Curr==(LAPU_Size-1)){
						Matmul_Next_State=Matmul_FetchB;
						Kc_Counter_Next=0;
						Mc_Counter_Next=0;

					}

					//wait for PEs to get the data
					Latency_Counter_Next=0;
					Latency_Counter_Curr=0;



				break;


				case Matmul_FetchB:

					Kc_Counter_Next=(Kc_Counter_Curr+1);

					if (Kc_Counter_Curr==(Kernel_Size-1)){ //bus latency is 1
						Matmul_Next_State=Matmul_FetchA;
						Kc_Counter_Next=0;
						Mc_Counter_Next=0;

					}

				break;


				case Matmul_FetchA:
          
          //Mochamad --> This was updated by Ardavan
  

					/*
					Kc_Counter_Next=(Kc_Counter_Curr+1) % Kernel_Size;
					Matmul_Next_State=Matmul_FetchA;

					if (Kc_Counter_Curr== (Kernel_Size -1)){

						Mc_Counter_Next=(Mc_Counter_Curr+LAPU_Size)% Kernel_Size;
						//Mc_Counter_Next=(Mc_Counter_Curr+1)% Kernel_Size;

						if (Mc_Counter_Curr==(Kernel_Size-LAPU_Size)){
						//if (Mc_Counter_Curr==(Kernel_Size-1)){
							Matmul_Next_State=Matmul_BC0;
							//Matmul_Next_State=Matmul_End;
							Kc_Counter_Next=0;
							Mc_Counter_Next=0;

						}
					}
					 */


					Kc_Counter_Next=(Kc_Counter_Curr+LAPU_Size) % Kernel_Size;
					Matmul_Next_State=Matmul_FetchA;

					if (Kc_Counter_Curr== (Kernel_Size -LAPU_Size)){

						Mc_Counter_Next=(Mc_Counter_Curr+1)% Kernel_Size;
						//Mc_Counter_Next=(Mc_Counter_Curr+1)% Kernel_Size;

						if (Mc_Counter_Curr==(Kernel_Size-1)){
						//if (Mc_Counter_Curr==(Kernel_Size-1)){
							Matmul_Next_State=Matmul_BC0;
							//Matmul_Next_State=Matmul_End;
							Kc_Counter_Next=0;
							Mc_Counter_Next=0;

						}
					}


				break;

				case Matmul_BC0: // Write_Row_Reg<-SRAM[A(0,0)] in the previous state
					// just BC the 0th
					// and read the 1st from the SRAM
					//Nothing is on the bus
					//Matmul_Next_State=Matmul_End;
					Matmul_Next_State=Matmul_BC;

				break;


				case Matmul_BC:  // it loops equal to bus delay for future

					Matmul_Next_State= Matmul_MAC_BC;
					Kc_Counter_Next=Kc_Counter_Curr+1;

				break;

				case Matmul_MAC_BC:

						Matmul_Next_State=Matmul_MAC_BC;

            /*cout << "Kc and Mc in FSM are" << Kc_Counter_Curr 
                 << " " << Mc_Counter_Curr << endl;
            getchar();*/

						Kc_Counter_Next=(Kc_Counter_Curr+1) % Kernel_Size;
						if (Kc_Counter_Curr== (Kernel_Size -1)){
							Mc_Counter_Next=(Mc_Counter_Curr+LAPU_Size)% Kernel_Size;
							if (Mc_Counter_Curr==(Kernel_Size-LAPU_Size)){
								N_Counter_Next=(N_Counter_Curr+LAPU_Size)% Panel_Size;
								if (N_Counter_Curr== (Panel_Size -LAPU_Size)){
                  Ma_Counter_Next = Ma_Counter + 1
                  if (Ma_Counter_Curr == NumofA - 1){
								  	Matmul_Next_State=Matmul_MAC_Flush;
                  }
                }

							}

						}


				break;

				case Matmul_MAC_Flush:
        
          //updated by Mochamad 
          
          //Kc_Counter_Next=(Kc_Counter_Curr+1) % Kernel_Size;
          

					Latency_Counter_Next=Latency_Counter_Curr+1;

					if (Latency_Counter_Curr< (FMA_Latency-1))
						Matmul_Next_State=Matmul_MAC_Flush;
					else{
						Matmul_Next_State=Matmul_End;
						Latency_Counter_Next=0;
					}
				break;


				case Matmul_End:

          //getchar();
          
          if (Last_Sending==LAPU_Size) done =true;
          
          Last_Sending++;

					Kc_Counter_Next=0;
					Kc_Counter_Curr=0;
					Mc_Counter_Curr=0;
					Mc_Counter_Next=0;
					N_Counter_Curr=0;
					N_Counter_Next=0;

				break;


			}

			if (Print_State_Machines==1){
				cout<<"==============================";
				cout<<"Cycle"<<Cycles_Passed<<endl;
			//	char test2;
			//	cout<<"Press Enter"<<endl;
			//	cin>>test2;
				Dump_Matmul_SMachine();
			}
			for (i=0;i<Size;i++)
				for (j=0;j<Size;j++){
					PE_Array[i][j].Execute_Matmul (Global_index, N_Counter_Curr, Mc_Counter_Curr, Kc_Counter_Curr, Matmul_Current_State, Latency_Counter_Curr);
					// We pass this Routine an the current state of this routine to PE
				}

			//Sqrt_Unit->Execute(Global_index, Counter_Curr, Latency_Counter_Curr,
				//	LAPU_Rank_Update, Gemm_Current_State, State_Start ); // TODO fix the input;

			Mem_IF->IO_Execute_Matmul (Global_index, N_Counter_Curr, Mc_Counter_Curr, Kc_Counter_Curr, Matmul_Current_State, Latency_Counter_Curr);

			 if ((Matmul_Current_State==Matmul_End) && done){
				 Matmul_Current_State=Matmul_Init;
				 Matmul_Next_State=Matmul_Init;
				 return Cycles_Passed;
			 }
			Dump_Row_Buses();
			Dump_Column_Buses();

			Drive_Buses(); // Can it be a part of Cycle function? I remember I just separated it for readability
			// It does not matter which one comes first Drive_Bus or Cycle;

			/*if (Kc_Counter_Curr==0 && Matmul_Current_State==Matmul_MAC_BC) {
				getchar();
			}*/
			Cycle();


	    	}

    }
